import os
import json
import logging
import gspread
from google.oauth2 import service_account
from datetime import datetime, timedelta

logger = logging.getLogger("ferrik.sheets")
GOOGLE_SHEET_ID = os.environ.get("GOOGLE_SHEET_ID", "").strip()
CREDS_JSON = os.environ.get("CREDS_JSON")  # якщо ти зберігаєш весь creds.json тут
SERVICE_ACCOUNT_KEY_PATH = os.environ.get("SERVICE_ACCOUNT_KEY_PATH", "").strip()  # або шлях до файлу

SCOPE = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive"
]

gc = None
spreadsheet = None
_menu_cache = []
_menu_cache_time = None
CACHE_TTL = int(os.environ.get("MENU_CACHE_TTL_SECONDS", "900"))  # 15 min

def init_gspread_client():
    """
    Ініціалізує клієнт gspread для роботи з Google Sheets.
    Використовує або CREDS_JSON зі змінної середовища, або файл ключа.
    """
    global gc, spreadsheet
    if gc:
        return True

    try:
        creds = None
        if CREDS_JSON:
            logger.info("Using CREDS_JSON from env to init gspread")
            info = json.loads(CREDS_JSON)
            creds = service_account.Credentials.from_service_account_info(info, scopes=SCOPE)
        elif SERVICE_ACCOUNT_KEY_PATH and os.path.exists(SERVICE_ACCOUNT_KEY_PATH):
            logger.info("Using service account file: %s", SERVICE_ACCOUNT_KEY_PATH)
            creds = service_account.Credentials.from_service_account_file(SERVICE_ACCOUNT_KEY_PATH, scopes=SCOPE)
        else:
            logger.error("No Google credentials found. Set CREDS_JSON or SERVICE_ACCOUNT_KEY_PATH.")
            return False

        gc = gspread.authorize(creds)
        if not GOOGLE_SHEET_ID:
            logger.error("GOOGLE_SHEET_ID not set.")
            return False
        spreadsheet = gc.open_by_key(GOOGLE_SHEET_ID)
        logger.info("Connected to Google Sheet: %s", GOOGLE_SHEET_ID)
        return True
    except Exception as e:
        logger.exception("init_gspread_client error: %s", e)
        return False

def _parse_price(price_raw):
    """Допоміжна функція для безпечного парсингу ціни."""
    try:
        # Замінюємо кому на крапку і парсимо в float
        return float(str(price_raw).strip().replace(",", "."))
    except (ValueError, TypeError):
        return 0.0

def update_menu_cache(force=False):
    """
    Оновлює кеш меню з Google Sheets, якщо кеш застарів або force=True.
    """
    global _menu_cache, _menu_cache_time
    try:
        if not init_gspread_client():
            return []

        now = datetime.utcnow()
        if not force and _menu_cache and _menu_cache_time and (now - _menu_cache_time).total_seconds() < CACHE_TTL:
            logger.info("Using cached menu. Next update in %.1f seconds.", CACHE_TTL - (now - _menu_cache_time).total_seconds())
            return _menu_cache

        ws = spreadsheet.worksheet("Меню")
        records = ws.get_all_records()
        processed = []
        for r in records:
            # нормалізація полів
            name = (r.get("Назва Страви") or r.get("Назва") or "").strip()
            item_id = str(r.get("ID") or "").strip()
            
            if not name or not item_id:
                # Пропускаємо рядки без назви або ID
                continue

            processed.append({
                "ID": item_id,
                "name": name,
                "price": _parse_price(r.get("Ціна", 0)),
                "description": (r.get("Опис") or "").strip(),
                "photo": (r.get("Фото URL") or "").strip(),
                "active": str(r.get("Активний", "Так")).strip().lower() in ("так", "yes", "true")
            })
            
        _menu_cache = [p for p in processed if p.get("active")]
        _menu_cache_time = now
        logger.info("Menu loaded: %d active items", len(_menu_cache))
        return _menu_cache
    except gspread.exceptions.WorksheetNotFound:
        logger.error("Worksheet 'Меню' not found in the spreadsheet.")
        return []
    except Exception as e:
        logger.exception("update_menu_cache error: %s", e)
        return []

def get_menu_from_cache():
    """Повертає поточний кешований список меню."""
    return _menu_cache

def get_menu_item_by_id(item_id):
    """
    Шукає і повертає елемент меню за його ID з кешу.
    Повертає None, якщо елемент не знайдено.
    """
    global _menu_cache
    if not _menu_cache:
        update_menu_cache()
    
    for item in _menu_cache:
        if item.get("ID") == item_id:
            return item
    return None
