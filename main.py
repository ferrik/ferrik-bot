import os
import logging
from flask import Flask, request, jsonify
from datetime import datetime
from collections import defaultdict
from decimal import Decimal, InvalidOperation, ROUND_HALF_UP
from html import escape as html_escape
from threading import RLock

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)

# Thread-safe locks
carts_lock = RLock()
states_lock = RLock()

# –Ü–º–ø–æ—Ä—Ç–∏
logger.info("Starting Hubsy Bot...")

try:
    from config import (
        BOT_TOKEN, GEMINI_API_KEY, SPREADSHEET_ID, 
        WEBHOOK_SECRET, validate_config, log_config
    )
    
    if not BOT_TOKEN:
        logger.critical("BOT_TOKEN not set")
        raise RuntimeError("BOT_TOKEN is required")
    
    if not WEBHOOK_SECRET:
        logger.critical("WEBHOOK_SECRET not set")
        raise RuntimeError("WEBHOOK_SECRET must be set")
    
    logger.info("Config imported successfully")
    
except Exception as e:
    logger.exception("Config error")
    raise

try:
    from services.sheets import get_menu_from_sheet, save_order_to_sheets, search_menu_items
    logger.info("Sheets service imported")
except Exception as e:
    logger.exception("Sheets import error")
    raise

try:
    from services.gemini import init_gemini_client, get_ai_response, is_gemini_connected
    logger.info("Gemini service imported")
except Exception as e:
    logger.exception("Gemini import error")
    raise

try:
    from services.telegram import tg_send_message, tg_answer_callback, tg_set_webhook
    logger.info("Telegram service imported")
except Exception as e:
    logger.exception("Telegram service import error")
    raise

# –ì–ª–æ–±–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ
menu_cache = []
user_carts = defaultdict(list)
user_states = {}

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∏ (–∞–¥–∞–ø—Ç–æ–≤–∞–Ω—ñ –ø—ñ–¥ –≤–∞—à—É —Ç–∞–±–ª–∏—Ü—é)
KEY_NAME = "–ù–∞–∑–≤–∞ –°—Ç—Ä–∞–≤–∏"  # –í sheets.py –∫–æ–Ω–≤–µ—Ä—Ç—É—î—Ç—å—Å—è –∑ "–°—Ç—Ä–∞–≤–∏"
KEY_PRICE = "–¶—ñ–Ω–∞"
KEY_CATEGORY = "–ö–∞—Ç–µ–≥–æ—Ä—ñ—è"
KEY_DESCRIPTION = "–û–ø–∏—Å"
KEY_WEIGHT = "–í–∞–≥–∞"
KEY_ID = "ID"
KEY_RESTAURANT = "–†–µ—Å—Ç–æ—Ä–∞–Ω"
KEY_RATING = "–†–µ–π—Ç–∏–Ω–≥"

MAX_CALLBACK_LENGTH = 64

def safe_callback_data(prefix: str, value: str) -> str:
    """–ë–µ–∑–ø–µ—á–Ω–∏–π callback_data"""
    safe_value = "".join(c for c in str(value) if c.isalnum() or c in "-_")
    callback = f"{prefix}_{safe_value}"
    return callback[:MAX_CALLBACK_LENGTH]

def parse_price(price_str) -> Decimal:
    """–ü–∞—Ä—Å–∏–Ω–≥ —Ü—ñ–Ω–∏ –≤ Decimal"""
    try:
        clean_price = str(price_str).replace(",", ".").strip()
        return Decimal(clean_price).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)
    except (InvalidOperation, ValueError) as e:
        logger.warning(f"Failed to parse price '{price_str}': {e}")
        return Decimal('0.00')

def send_message(chat_id, text, reply_markup=None, parse_mode="HTML"):
    """–í—ñ–¥–ø—Ä–∞–≤–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
    try:
        safe_text = text.replace("&", "&amp;")
        safe_text = safe_text.replace("<", "&lt;").replace(">", "&gt;")
        safe_text = safe_text.replace("&lt;b&gt;", "<b>").replace("&lt;/b&gt;", "</b>")
        safe_text = safe_text.replace("&lt;i&gt;", "<i>").replace("&lt;/i&gt;", "</i>")
        
        result = tg_send_message(chat_id, safe_text, reply_markup, parse_mode)
        
        if not result or not result.get('ok'):
            logger.error(f"Send failed: {result}")
            raise RuntimeError("Failed to send message")
        
        return result
        
    except Exception as e:
        logger.exception(f"Send error for chat {chat_id}")
        raise

def answer_callback(callback_id, text="", show_alert=False):
    """–í—ñ–¥–ø–æ–≤—ñ–¥—å –Ω–∞ callback"""
    try:
        return tg_answer_callback(callback_id, text, show_alert)
    except Exception as e:
        logger.exception(f"Callback answer error")
        return None

def init_services():
    """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Å–µ—Ä–≤—ñ—Å—ñ–≤"""
    global menu_cache
    
    logger.info("Initializing services...")
    
    try:
        log_config()
        validate_config()
    except Exception as e:
        logger.exception(f"Config error: {e}")
    
    try:
        menu_cache = get_menu_from_sheet()
        if menu_cache:
            logger.info(f"Menu cached: {len(menu_cache)} items")
        else:
            logger.warning("Menu is empty")
    except Exception as e:
        logger.exception(f"Menu loading error: {e}")
        menu_cache = []
    
    try:
        init_gemini_client()
        if is_gemini_connected():
            logger.info("Gemini initialized")
    except Exception as e:
        logger.exception(f"Gemini error: {e}")
    
    try:
        from config import RENDER_URL
        result = tg_set_webhook(RENDER_URL)
        if result and result.get('ok'):
            logger.info("Webhook set successfully")
        else:
            logger.error(f"Webhook failed: {result}")
    except Exception as e:
        logger.exception(f"Webhook error: {e}")

def get_categories():
    """–£–Ω—ñ–∫–∞–ª—å–Ω—ñ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó"""
    categories = set()
    for item in menu_cache:
        cat = item.get(KEY_CATEGORY, "")
        if cat:
            categories.add(cat)
    return sorted(list(categories))

def get_items_by_category(category):
    """–°—Ç—Ä–∞–≤–∏ –∑–∞ –∫–∞—Ç–µ–≥–æ—Ä—ñ—î—é"""
    return [item for item in menu_cache if item.get(KEY_CATEGORY) == category]

def format_item(item, show_full=False):
    """–§–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Å—Ç—Ä–∞–≤–∏"""
    name = html_escape(item.get(KEY_NAME, "–ë–µ–∑ –Ω–∞–∑–≤–∏"))
    price = item.get(KEY_PRICE, "?")
    
    if show_full:
        desc = html_escape(item.get(KEY_DESCRIPTION, ""))
        restaurant = html_escape(item.get(KEY_RESTAURANT, ""))
        rating = item.get(KEY_RATING, "")
        
        text = f"<b>{name}</b>\n"
        if desc:
            text += f"{desc}\n"
        if restaurant:
            text += f"üè™ {restaurant}\n"
        if rating:
            text += f"‚≠ê {rating}\n"
        text += f"üí∞ <b>{price} –≥—Ä–Ω</b>"
        return text
    else:
        return f"{name} - {price} –≥—Ä–Ω"

def handle_start(chat_id):
    """–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é"""
    text = (
        "üëã –í—ñ—Ç–∞—î–º–æ –≤ <b>Hubsy</b>!\n\n"
        "üçï –í–∞—à –ø–æ–º—ñ—á–Ω–∏–∫ –¥–ª—è –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è —ó–∂—ñ.\n\n"
        "–û–±–µ—Ä—ñ—Ç—å –¥—ñ—é:"
    )
    
    keyboard = {
        "inline_keyboard": [
            [{"text": "üìñ –ú–µ–Ω—é", "callback_data": "show_categories"}],
            [
                {"text": "üîç –ü–æ—à—É–∫", "callback_data": "search_mode"},
                {"text": "üõí –ö–æ—Ä–∑–∏–Ω–∞", "callback_data": "show_cart"}
            ],
            [
                {"text": "‚ú® AI-–ü–æ—Ä–∞–¥–∞", "callback_data": "ai_recommend"},
                {"text": "üìû –ö–æ–Ω—Ç–∞–∫—Ç–∏", "callback_data": "contacts"}
            ]
        ]
    }
    
    send_message(chat_id, text, reply_markup=keyboard)

def show_categories(chat_id):
    """–ü–æ–∫–∞–∑–∞—Ç–∏ –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó"""
    categories = get_categories()
    
    if not categories:
        send_message(chat_id, "‚ùå –ú–µ–Ω—é —Ç–∏–º—á–∞—Å–æ–≤–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–µ")
        return
    
    text = "üìñ <b>–û–±–µ—Ä—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é:</b>"
    keyboard = {"inline_keyboard": []}
    
    category_emoji = {
        "–ü—ñ—Ü–∞": "üçï", "–ë—É—Ä–≥–µ—Ä–∏": "üçî", "–°—É—à—ñ": "üç£",
        "–°–∞–ª–∞—Ç–∏": "ü•ó", "–ù–∞–ø–æ—ó": "ü•§", "–î–µ—Å–µ—Ä—Ç–∏": "üç∞"
    }
    
    for cat in categories:
        emoji = category_emoji.get(cat, "üçΩÔ∏è")
        safe_cat = safe_callback_data("cat", cat)
        keyboard["inline_keyboard"].append([
            {"text": f"{emoji} {cat}", "callback_data": safe_cat}
        ])
    
    keyboard["inline_keyboard"].append([
        {"text": "üîô –ù–∞–∑–∞–¥", "callback_data": "start"}
    ])
    
    send_message(chat_id, text, reply_markup=keyboard)

def show_category_items(chat_id, category):
    """–ü–æ–∫–∞–∑–∞—Ç–∏ —Å—Ç—Ä–∞–≤–∏"""
    items = get_items_by_category(category)
    
    if not items:
        send_message(chat_id, f"–í –∫–∞—Ç–µ–≥–æ—Ä—ñ—ó <b>{html_escape(category)}</b> –Ω–µ–º–∞—î —Å—Ç—Ä–∞–≤")
        return
    
    text = f"üìã <b>{html_escape(category)}</b>\n\n"
    keyboard = {"inline_keyboard": []}
    
    for i, item in enumerate(items[:10]):
        item_text = format_item(item)
        text += f"{i+1}. {item_text}\n"
        
        item_id = str(item.get(KEY_ID, item.get(KEY_NAME, "")))
        safe_id = safe_callback_data("add", item_id)
        
        keyboard["inline_keyboard"].append([
            {"text": f"‚ûï {item.get(KEY_NAME, '')[:20]}", "callback_data": safe_id}
        ])
    
    keyboard["inline_keyboard"].append([
        {"text": "üîô –ö–∞—Ç–µ–≥–æ—Ä—ñ—ó", "callback_data": "show_categories"},
        {"text": "üè† –ì–æ–ª–æ–≤–Ω–∞", "callback_data": "start"}
    ])
    
    send_message(chat_id, text, reply_markup=keyboard)

def add_to_cart(chat_id, item_id):
    """–î–æ–¥–∞—Ç–∏ –≤ –∫–æ—Ä–∑–∏–Ω—É"""
    item = None
    for menu_item in menu_cache:
        if str(menu_item.get(KEY_ID, "")) == str(item_id) or menu_item.get(KEY_NAME) == item_id:
            item = menu_item
            break
    
    if not item:
        return "‚ùå –°—Ç—Ä–∞–≤—É –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ"
    
    with carts_lock:
        user_carts[chat_id].append(item)
    
    name = html_escape(item.get(KEY_NAME, "–°—Ç—Ä–∞–≤–∞"))
    return f"‚úÖ <b>{name}</b> –¥–æ–¥–∞–Ω–æ!"

def show_cart(chat_id):
    """–ü–æ–∫–∞–∑–∞—Ç–∏ –∫–æ—Ä–∑–∏–Ω—É"""
    with carts_lock:
        cart = list(user_carts.get(chat_id, []))
    
    if not cart:
        text = "üõí –ö–æ—Ä–∑–∏–Ω–∞ –ø–æ—Ä–æ–∂–Ω—è\n\n–î–æ–¥–∞–π—Ç–µ —Å—Ç—Ä–∞–≤–∏ –∑ –º–µ–Ω—é!"
        keyboard = {
            "inline_keyboard": [[
                {"text": "üìñ –ú–µ–Ω—é", "callback_data": "show_categories"}
            ]]
        }
        send_message(chat_id, text, reply_markup=keyboard)
        return
    
    total = Decimal('0.00')
    items_count = defaultdict(int)
    
    for item in cart:
        name = item.get(KEY_NAME, "")
        items_count[name] += 1
        price = parse_price(item.get(KEY_PRICE, 0))
        total += price
    
    text = "üõí <b>–í–∞—à–µ –∑–∞–º–æ–≤–ª–µ–Ω–Ω—è:</b>\n\n"
    
    for name, count in items_count.items():
        safe_name = html_escape(name)
        text += f"‚Ä¢ {safe_name} x{count}\n"
    
    text += f"\nüí∞ <b>–°—É–º–∞: {total:.2f} –≥—Ä–Ω</b>"
    
    keyboard = {
        "inline_keyboard": [
            [{"text": "‚úÖ –û—Ñ–æ—Ä–º–∏—Ç–∏", "callback_data": "checkout"}],
            [{"text": "üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç–∏", "callback_data": "clear_cart"}],
            [{"text": "‚ûï –î–æ–¥–∞—Ç–∏ —â–µ", "callback_data": "show_categories"}],
            [{"text": "üîô –ù–∞–∑–∞–¥", "callback_data": "start"}]
        ]
    }
    
    send_message(chat_id, text, reply_markup=keyboard)

def clear_cart(chat_id):
    """–û—á–∏—Å—Ç–∏—Ç–∏ –∫–æ—Ä–∑–∏–Ω—É"""
    with carts_lock:
        user_carts[chat_id] = []
    return "üóëÔ∏è –ö–æ—Ä–∑–∏–Ω—É –æ—á–∏—â–µ–Ω–æ"

def checkout(chat_id):
    """–û—Ñ–æ—Ä–º–ª–µ–Ω–Ω—è"""
    with carts_lock:
        cart = list(user_carts.get(chat_id, []))
    
    if not cart:
        return "‚ùå –ö–æ—Ä–∑–∏–Ω–∞ –ø–æ—Ä–æ–∂–Ω—è"
    
    try:
        save_order_to_sheets(chat_id, cart)
        
        with carts_lock:
            user_carts[chat_id] = []
        
        text = (
            "‚úÖ <b>–ó–∞–º–æ–≤–ª–µ–Ω–Ω—è –ø—Ä–∏–π–Ω—è—Ç–æ!</b>\n\n"
            "üìû –ú–µ–Ω–µ–¥–∂–µ—Ä –∑–≤'—è–∂–µ—Ç—å—Å—è –∑ –≤–∞–º–∏.\n\n"
            "–î—è–∫—É—î–º–æ! üíô"
        )
        
        keyboard = {
            "inline_keyboard": [[
                {"text": "üè† –ì–æ–ª–æ–≤–Ω–∞", "callback_data": "start"}
            ]]
        }
        
        send_message(chat_id, text, reply_markup=keyboard)
        return None
        
    except Exception as e:
        logger.exception(f"Checkout error: {e}")
        return "‚ùå –ü–æ–º–∏–ª–∫–∞. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ."

def show_contacts(chat_id):
    """–ö–æ–Ω—Ç–∞–∫—Ç–∏"""
    text = """
üìû <b>–ö–æ–Ω—Ç–∞–∫—Ç–∏ Hubsy</b>

üì± –¢–µ–ª–µ—Ñ–æ–Ω: +380 XX XXX XX XX
üìß Email: hello@hubsy.com
üìç –º. –ö–∏—ó–≤

üïê –©–æ–¥–Ω—è 9:00-23:00
"""
    
    keyboard = {
        "inline_keyboard": [[
            {"text": "üîô –ù–∞–∑–∞–¥", "callback_data": "start"}
        ]]
    }
    
    send_message(chat_id, text, reply_markup=keyboard)

def ai_recommend(chat_id):
    """AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó"""
    if not is_gemini_connected():
        text = "‚ùå AI –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π"
        keyboard = {
            "inline_keyboard": [[
                {"text": "üîô –ù–∞–∑–∞–¥", "callback_data": "start"}
            ]]
        }
        send_message(chat_id, text, reply_markup=keyboard)
        return
    
    try:
        categories = get_categories()
        prompt = f"–¢–∏ –ø–æ–º—ñ—á–Ω–∏–∫ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—É Hubsy. –ü–æ—Ä–µ–∫–æ–º–µ–Ω–¥—É–π 2-3 —Å—Ç—Ä–∞–≤–∏. –ö–∞—Ç–µ–≥–æ—Ä—ñ—ó: {', '.join(categories)}. –ö–æ—Ä–æ—Ç–∫–æ 2-3 —Ä–µ—á–µ–Ω–Ω—è."
        
        recommendation = get_ai_response(prompt)
        
        text = f"‚ú® <b>AI-–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—è:</b>\n\n{recommendation}"
        
        keyboard = {
            "inline_keyboard": [
                [{"text": "üìñ –ú–µ–Ω—é", "callback_data": "show_categories"}],
                [{"text": "üîÑ –Ü–Ω—à–∞ –ø–æ—Ä–∞–¥–∞", "callback_data": "ai_recommend"}],
                [{"text": "üîô –ù–∞–∑–∞–¥", "callback_data": "start"}]
            ]
        }
        
        send_message(chat_id, text, reply_markup=keyboard)
        
    except Exception as e:
        logger.exception(f"AI error: {e}")
        send_message(chat_id, "‚ùå –ü–æ–º–∏–ª–∫–∞ AI")

def search_mode(chat_id):
    """–ü–æ—à—É–∫"""
    with states_lock:
        user_states[chat_id] = 'searching'
    
    text = "üîç <b>–ü–æ—à—É–∫</b>\n\n–ù–∞–ø–∏—à—ñ—Ç—å –Ω–∞–∑–≤—É —Å—Ç—Ä–∞–≤–∏:"
    
    keyboard = {
        "inline_keyboard": [[
            {"text": "‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", "callback_data": "start"}
        ]]
    }
    
    send_message(chat_id, text, reply_markup=keyboard)

def process_search(chat_id, query):
    """–û–±—Ä–æ–±–∫–∞ –ø–æ—à—É–∫—É"""
    results = search_menu_items(query)
    
    if not results:
        text = f"‚ùå –ù—ñ—á–æ–≥–æ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ: '<b>{html_escape(query)}</b>'"
        keyboard = {
            "inline_keyboard": [[
                {"text": "üìñ –í—Å–µ –º–µ–Ω—é", "callback_data": "show_categories"}
            ]]
        }
        send_message(chat_id, text, reply_markup=keyboard)
        return
    
    text = f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç–∏ '<b>{html_escape(query)}</b>':\n\n"
    keyboard = {"inline_keyboard": []}
    
    for item in results[:10]:
        item_text = format_item(item)
        text += f"‚Ä¢ {item_text}\n"
        
        item_id = str(item.get(KEY_ID, item.get(KEY_NAME, "")))
        safe_id = safe_callback_data("add", item_id)
        
        keyboard["inline_keyboard"].append([
            {"text": f"‚ûï {item.get(KEY_NAME, '')[:25]}", "callback_data": safe_id}
        ])
    
    keyboard["inline_keyboard"].append([
        {"text": "üîç –ù–æ–≤–∏–π –ø–æ—à—É–∫", "callback_data": "search_mode"},
        {"text": "üè† –ì–æ–ª–æ–≤–Ω–∞", "callback_data": "start"}
    ])
    
    send_message(chat_id, text, reply_markup=keyboard)
    
    with states_lock:
        user_states[chat_id] = None

def process_callback_query(callback_query):
    """–û–±—Ä–æ–±–∫–∞ callback"""
    try:
        chat_id = callback_query["message"]["chat"]["id"]
        callback_id = callback_query["id"]
        data = callback_query["data"]
        
        logger.info(f"Callback {data} from chat {chat_id}")
        
        answer_callback(callback_id, "‚è≥")
        
        if data == "start":
            handle_start(chat_id)
        elif data == "show_categories":
            show_categories(chat_id)
        elif data.startswith("cat_"):
            category = data[4:]
            show_category_items(chat_id, category)
        elif data.startswith("add_"):
            item_id = data[4:]
            msg = add_to_cart(chat_id, item_id)
            answer_callback(callback_id, msg, show_alert=True)
        elif data == "show_cart":
            show_cart(chat_id)
        elif data == "clear_cart":
            msg = clear_cart(chat_id)
            answer_callback(callback_id, msg, show_alert=True)
            show_cart(chat_id)
        elif data == "checkout":
            msg = checkout(chat_id)
            if msg:
                answer_callback(callback_id, msg, show_alert=True)
        elif data == "ai_recommend":
            ai_recommend(chat_id)
        elif data == "contacts":
            show_contacts(chat_id)
        elif data == "search_mode":
            search_mode(chat_id)
        else:
            logger.warning(f"Unknown callback: {data}")
            
    except KeyError as e:
        logger.exception(f"Callback structure error: {e}")
    except Exception as e:
        logger.exception(f"Callback error: {e}")

def process_message(message):
    """–û–±—Ä–æ–±–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å"""
    try:
        chat_id = message["chat"]["id"]
        text = message.get("text", "")
        
        logger.info(f"Message from chat {chat_id}")
        
        with states_lock:
            state = user_states.get(chat_id)
        
        if state == 'searching':
            process_search(chat_id, text)
            return
        
        if text == "/start":
            handle_start(chat_id)
        elif text == "/menu":
            show_categories(chat_id)
        elif text == "/cart":
            show_cart(chat_id)
        else:
            send_message(chat_id, "–°–ø—Ä–æ–±—É–π—Ç–µ /start")
                
    except KeyError as e:
        logger.exception(f"Message structure error: {e}")
    except Exception as e:
        logger.exception(f"Message error: {e}")

@app.route('/health', methods=['GET'])
def health():
    """Health check"""
    return jsonify({
        'status': 'healthy',
        'menu_items': len(menu_cache),
        'timestamp': datetime.now().isoformat()
    })

@app.route('/', methods=['GET'])
def index():
    """Index"""
    return jsonify({
        'status': 'ok',
        'bot': 'Hubsy',
        'version': '2.0'
    })

@app.route('/webhook', methods=['POST'])
def webhook():
    """Webhook"""
    header_secret = request.headers.get("X-Telegram-Bot-Api-Secret-Token")
    
    if not header_secret or header_secret != WEBHOOK_SECRET:
        logger.warning(f"Unauthorized from {request.remote_addr}")
        return jsonify({'status': 'unauthorized'}), 401
    
    try:
        update = request.get_json(force=False)
        
        if not update:
            return jsonify({'status': 'ok'})
        
        logger.info(f"Update {update.get('update_id', '?')}")
        
        if 'message' in update:
            process_message(update['message'])
        elif 'callback_query' in update:
            process_callback_query(update['callback_query'])
        
        return jsonify({'status': 'ok'})
        
    except ValueError as e:
        logger.exception("Invalid JSON")
        return jsonify({'error': 'invalid json'}), 400
    except Exception as e:
        logger.exception(f"Webhook error: {e}")
        return jsonify({'error': 'server error'}), 500

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Not found"}), 404

@app.errorhandler(500)
def internal_error(error):
    logger.exception("Internal error")
    return jsonify({"error": "Internal error"}), 500

with app.app_context():
    init_services()

if __name__ == "__main__":
    logger.warning("Use gunicorn for production")
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=False)